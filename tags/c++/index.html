<!DOCTYPE html>
<html><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <meta name="author" content="Ovaar" />
  
  <meta name="description" content="Software Engineering blog" />
  
  <title>
    
      C&#43;&#43; - Ovaar - Software engineering blog
    
  </title>
   
   
   
  
  <link rel="stylesheet" href="/css/stylesheet.min.css" />
  <link href="/tags/c&#43;&#43;/index.xml" rel="feed" type="application/rss+xml" title="Ovaar - Software engineering blog">
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-173180646-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
      
      <header><nav>
  
  <a href="https://ovaar.github.io/">Ovaar - Software engineering blog</a>
  
  <ul>
    <li>
      <a href="https://ovaar.github.io/">Home</a>
    </li>
    <li>
      <a href="https://ovaar.github.io/blog/">Blog</a>
    </li>
	
  </ul>
</nav>
<h1>Blog Posts</h1>
        
        
        <nav class="list-nav">
          
          
          <a href="/tags/c&#43;&#43;/page/2/">next page</a>
          
        </nav>
        
      </header>
      <main>
        
        <article>
          <a href="https://ovaar.github.io/blog/azure-pipelines-cross-platform-scripts/">
            <h3>Azure pipelines cross-platform scripts</h3>
          </a>
          <p>Azure pipelines cross-platform scripts To keep things simple when setting up a CI/CD pipeline for a cross-platform application we cautiously have to consider our options for running the steps in what scripting language, because we don&rsquo;t want to end up with scripts that do the same thing functionally, but are different for each platform, which means extra maintenance and complexity for the maintainers.
So we have to consider languages like Powershell, Bash, Zsh or Python for to run on Windows, macOS and Linux.</p>
          <p>
            <small>published on Thu, 01 Aug 2024</small>
          </p>
        </article>
        
        <article>
          <a href="https://ovaar.github.io/blog/how-to-typed-command-line-arguments-in-python/">
            <h3>How to typed command line arguments in python</h3>
          </a>
          <p>How to typed command line arguments in python Creating tools with python is a common practice due to its ease of use and productivity. Now python already has good built-in support for parsing command-line arguments, but we can take it one step further.
Let&rsquo;s take the following example where we would like to create a platform independent build script that should be able to accept the build type and an option to rebuild.</p>
          <p>
            <small>published on Mon, 22 Apr 2024</small>
          </p>
        </article>
        
        <article>
          <a href="https://ovaar.github.io/blog/how-to-call-function-of-file-in-python/">
            <h3>How to call a function of a file in python</h3>
          </a>
          <p>How to call a function of a file in python Take the following use case, where I have a script that I use in my Continues Integration (CI) pipeline and I would like to call a function in that file from the command-line with parameters.
 The inspect module provides several useful functions to help get information about live objects such as modules, classes, methods, functions, tracebacks, frame objects, and code objects.</p>
          <p>
            <small>published on Fri, 17 Nov 2023</small>
          </p>
        </article>
        
        <article>
          <a href="https://ovaar.github.io/blog/practical-cppstd17/">
            <h3>Practical cppstd 17 highlights by example</h3>
          </a>
          <p>Practical cppstd 17 highlights by example  Language Features Library Features  Language Features Nested namespace definitions namespace A::B::C { // ... } // Rather than: namespace A { namespace B { namespace C { // ...  } } } Structured bindings #include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct Vector3 { float X; float Y; float Z; }; using MappingPair = std::pair&lt;int, std::string&gt;; int main() { const auto [x, y, z] = Vector3{1.</p>
          <p>
            <small>published on Mon, 06 Mar 2023</small>
          </p>
        </article>
        
        <article>
          <a href="https://ovaar.github.io/blog/cpp-make-variant-alternatives-array/">
            <h3>Create an array of all possible variants alternatives of std::variant type</h3>
          </a>
          <p>The standard library std::variant is a usefull feature, introduced since c++17, to define a type that can hold multiple alternative types.
For example a cell of a CSV file could represent multiple data types such as a string or int. Declaring a new type std::variant&lt;std::string, int&gt; allows to store one of the alternative types at the time. The std::variant internally allocates space for the largest alternative type.
 But what if you need to extract what the possible alternatives of the std::variant ?</p>
          <p>
            <small>published on Thu, 02 Mar 2023</small>
          </p>
        </article>
        
      </main>
      <footer><hr>

</footer>
    </body>
</html>
